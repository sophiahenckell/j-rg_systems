import unittest

import numpy as np
from scipy.optimize import minimize

from bedsim.system import System

from bedsim.plot.sysplot import Plot

# timing with:
# import time
# time.time()

def numeq(x, y):
    """
    Function to determine approx equality of two numeric variables
    """
    epsilon = 10**-10
    return np.abs(x-y) < epsilon

def numapprox(x, y):
    """
    Function to determine approx equality of two numeric variables
    """
    epsilon = 10**-5
    return np.abs(x-y) < epsilon

class arb(object):
    """
    Arbitrary class for testing purposes.
    """
    pass


class TestSystem(unittest.TestCase):
    """
    2x2 system test
    FIXME: also test ellipses!
    """

    def setUp(self):
        self.system = System()
        # Load the system from the 2x2 file which was generated by the test_sysgen module
        self.system.config_filename = "bedsim/data/test/EllipseGrid-2x2.h5"
        self.system.load_from_file()

    def test_overlap(self):
        # Select one particle to perform tests with
        [t1, t2] = self.system._particles[:2]
        (o1, o2) = (t1.position, t2.position)
        (v1, v2) = (t1.velocity, t2.velocity)
        self.assertEqual(t1.overlap(t2, 0), False)
        
        # move t1 to t2 and test again ;)
        t1.position = np.array([0.2, 1.30]) # FIXME: does it touch or overlap?
        self.assertEqual(t1.overlap(t2, 0), True)
        
        # test correction move
        t1.velocity = np.array([0,1]) # there must be a reason for t1 to overlap with t2
        t1.correction(t2)
        #print("CORR: v1=",t1.velocity, "; v2=",t2.velocity)
        self.assertTrue((t1.velocity == np.array([0,0])).all()) ## FIXME: check manually if correct
        self.assertTrue((t2.velocity == np.array([0,1])).all()) ## FIXME: same here
        (t1.position, t2.position) = (o1, o2) # reset position or we will break the cell assignment # FIXME: maybe couple translation and cell assignment
        (t1.velocity, t2.velocity) = (v1, v2)

        # now test the most difficult case: overlap through a border
        t1.position = np.array([1.95, 1.4])
        t2.position = np.array([0.05, 1.4])
        self.assertEqual(t1.overlap(t2, 0), True)
        (t1.position, t2.position) = (o1, o2) # ...and reset
        



    def test_timing_algorithms(self):
        [t1, t2] = self.system._particles[:2]
        
        """
        1. Test: cell-crossing through an inner cell (not through boundary)
        """
        t1.velocity = np.array([0.0,1.0])
        t1.position = t1.position + np.array([0,0.1])

        # Test cell crossing
        #print(t1.cell_crossing_time())
        (t, c, p) = t1.cell.crossing_time(t1.position, t1.velocity)
        self.assertTrue( numeq(p, np.array([0.2, 0.8])).all())
        self.assertTrue( numeq(t, 0.3))
        
        # Test collision
        self.assertTrue( numapprox(t1.collision_time(t2), np.array([0.7, 0.2, 1.3])).all())
        self.assertTrue( numapprox(t1.tpw_collision_time(t2), np.array([0.7, 0.2, 1.3])).all())
        #print("\n\n>>>\nStandard method: ", t1.collision_time(t2))
        #print("tqw method: ", t1.tpw_collision_time(t2))
        

        """
        2. Test: cell-crossing through a boundary
        """
        t1.position = t1.position - np.array([0,0.1]) # reset
        
        t1.velocity = np.array([0,-1])
        #print(t1.collision_time(t2))
        #print("t1 inter boundary crossing: ", t1.cell_crossing_time())
        (t, c, p) = t1.cell.crossing_time(t1.position, t1.velocity)
        self.assertEqual( numeq(p, np.array([0.2, 2.0])).all(), True)
        self.assertEqual( numeq(t, 0.4), True)


    def test_plot(self):
        p = Plot(self.system)
        p.system_sync()
        p.plot_system('bedsim/data/test/EllipseGrid-2x2.eps')

    def test_minimizer(self):
        # this is just for understanding the minimization routines
        cons = ({'type': 'ineq', 'fun': lambda x: -10},
                {'type': 'ineq', 'fun': lambda x: 10})
        
        bnds = ((0, 2), 
                (0, 2),
                (0, 2))

        x0 = [1,1,1]
        
        f = lambda x: x[0]
        tolerance = 1e-12 # FIXME: BDsim2d uses different tolerance values
        res = minimize(fun=f, x0=x0, method='SLSQP', bounds=bnds, constraints=cons, tol=tolerance)
        #print(res)


    def test_collision_time_estimator(self):
        [t1, t2, t3, t4] = self.system._particles
        t1.position = np.array([0.5, 0.5])
        t2.position = np.array([0.5, 1.0])
        t3.position = np.array([1.9, 1.9])
        t4.position = np.array([1.9, 1.7])
        t1.axes = (0.25, 0.1)
        t2.axes = (0.25, 0.1)
        p = Plot(self.system)
        p.system_sync()
        p.plot_system('bedsim/data/test/EllipseGrid-2x2-MOD.eps')
        
        
        # test axes
        self.assertTrue( numeq(np.abs(t1._get_separating_axis(t2)), np.array([1,0])).all() )
        self.assertTrue( numeq(np.abs(t1._get_normal_axis(t2)), np.array([0,1])).all() )
        
        # test if projection leads to same tnpoint as in mathematica
        self.assertTrue( numapprox(t1._project_on(angle=np.pi/4), np.array([0.134629, 0.134629])).all() )
        
        # test if ellipse angle is taken into account correctly
        t1.angle = np.pi/8
        # test if projection leads to same tnpoint as in mathematica
        self.assertTrue( numapprox(t1._project_on(angle=np.pi/4+np.pi/8), np.array([0.134629, 0.134629])).all() ) # FIXME: check if correct
        t1.angle = 0 # reset
        
        # test (partly) negative axes
        self.assertTrue( numapprox(t1._project_on(angle=3*np.pi/2), np.array([0, -0.1])).all() ) # between 3rd and 4th quadrant
        self.assertTrue( numapprox(t1._project_on(angle=3*np.pi/4), np.array([-0.134629, 0.134629])).all() ) # 2nd quadrant
        
        
        # test interval generation
        #self.assertTrue( t1._get_normal_projection_interval(t=0, angle=0)       == 0.25 ) # FIXME: API will change!! => adapt once it's ready ;)
        self.assertTrue( numapprox( np.array(list(t1._get_normal_projection_interval(t=0, angle=np.pi/2))), (0.4, 0.6) ).any() )
        self.assertTrue( numapprox( np.array(list(t2._get_normal_projection_interval(t=0, angle=np.pi/2))), (0.9, 1.1) ).any() )
        #print( t1._get_normal_projection_interval(t=0, angle=np.pi/2) )
        #print( t2._get_normal_projection_interval(t=0, angle=np.pi/2) )

        self.assertIsNone( t1.approximate_collision_time(t2) )
        
        # now test if collision is detected correctly
        t1.angvel = 0.01 * np.pi
        t1.velocity = np.array([0,0.05])
        #print("t12c=",t1.approximate_collision_time(t2))
        #print("t12r=",t1.collision_time(t2))
        #print("t12ratio=",abs(1-(t1.approximate_collision_time(t2)[0] / t1.collision_time(t2)[0])))
        self.assertTrue( abs(1-(t1.approximate_collision_time(t2)[0] / t1.collision_time(t2)[0]))<0.5 ) # deviation less than 50%
        
        
        # now test the real ugly cases :P
        #print("\nTEST UGLY CASES:")
        t1.position = np.array([0.5,0.75])
        t1.velocity = np.array([0,0])
        t1.angle = 0.1 * np.pi
        t1.angvel = -0.1 * np.pi
        #t1.angle += t1.angvel * t1.approximate_collision_time(t2)[0] *2
        #t1.angle += t1.angvel * 1
        #t1.angle = -0.18 * np.pi
        p.plot_system('bedsim/data/test/EllipseGrid-2x2-MOD2.eps')
        #print("t12cA=",t1.approximate_collision_time(t2))
        #print("t12cE=",t1.collision_time(t2))
        # FIXME: finish test case!
         
        


class TestBillardSystem(unittest.TestCase):
    def setUp(self):
        self.system = System()
        # Load the system from the 5x5 file which was generated by the test_sysgen module
        self.system.config_filename = "bedsim/data/test/EllipseGrid-5x5.h5" 
        self.system.load_from_file()

    def test_timing_algorithms(self):
        t1 = self.system._particles[0]
        t2 = self.system._particles[5]

        # test crossing from first particle to next cell in x-direction
        t1.velocity = np.array([1,0])
        (t, c, p) = t1.cell.crossing_time(t1.position, t1.velocity)
        self.assertTrue( numeq(p, np.array([0.6, 0.4])).all() )
        self.assertTrue( numeq(t, 0.4) )
        
        # test if cell_crossing_time also works for cells which are not near to (0,0) (this tests the relative directions)
        t2.velocity = np.array([1,0])
        (t, c, p) = t2.cell.crossing_time(t2.position, t2.velocity)
        #print(t,",",c,",",p)
        # FIXME: fix needed! # files API changes seems to have mirrored the system # check this
        """self.assertTrue( numeq(p, np.array([1.6, 0.4])).all() ) # FIXME: seit Umstellung auf files API gibt es hier Probleme!
        self.assertTrue( numeq(t, 0.4) )
        
        # test if cell_crossing_time works for boundary cell crossing as well
        t2.velocity = np.array([0, -1])
        (t, c, p) = t2.cell_crossing_time()
        self.assertTrue( numeq(p, np.array([1.2, 5])).all() )
        self.assertTrue( numeq(t, 0.4) )"""
        

    def test_plot(self):
        p = Plot(self.system)
        p.system_sync()
        p.plot_system('bedsim/data/test/EllipseGrid-5x5.eps')



class TestP3System(unittest.TestCase):
    """
    2x2 P3 system test
    """

    def setUp(self):
        self.system = System()
        # Load the system from the 2x2 file which was generated by the test_sysgen module
        self.system.config_filename = "bedsim/data/test/P3EllipseGrid-2x2.h5" 
        self.system.load_from_file()

    def test_plot_P3(self):
        p = Plot(self.system)
        p.system_sync()
        p.plot_system('bedsim/data/test/P3EllipseGrid-2x2.eps')
    
    def test_plot_P3_Antrag(self):
        p = Plot(self.system)
        p.plot_system_fmantrag('bedsim/data/test/P3EllipseAntrag-2x2.eps')
        #print("Packing fraction", self.system.get_packing_fraction())
